Three-Server Distributed Web Infrastructure for www.foobar.com
Components
Load Balancer Server (HAProxy)

Web Server (Nginx)

Application Server

Database Server (MySQL Primary-Replica setup)

Application files (code base) deployed on Web & App servers

Diagram Description (Visualize a whiteboard sketch):

           Internet Users
                 |
                 v
          +----------------+
          |  Load Balancer |  (HAProxy)
          +----------------+
            /           \
           /             \
+----------------+  +----------------+
|  Web Server 1  |  |  App Server 1  |
|  (Nginx)       |  |                |
+----------------+  +----------------+
           \               /
            \             /
          +----------------+
          | Database Server |
          |  (MySQL Primary)|
          +----------------+
                   |
           +----------------+
           | MySQL Replica  |
           +----------------+


Explanation of Each Element
1. Load Balancer (HAProxy)
Why added:
It distributes incoming traffic evenly across multiple servers to avoid overloading one server.

Role: Acts as the entry point for all requests to www.foobar.com.

Distribution algorithm:

Round Robin: Distributes requests one-by-one sequentially to each backend server, cycling through the list.

How it works: First request → Web Server 1, second request → App Server 1, then back to Web Server 1, etc. (Assuming it balances between web & app servers or multiple app servers.)

Active-Active vs Active-Passive:

Active-Active: Both servers handle traffic simultaneously, increasing throughput and availability.

Active-Passive: One server handles traffic (active), while the other waits (passive) to take over if the active fails.

This setup uses Active-Active: Both web and app servers handle requests concurrently, improving performance and availability.

2. Web Server (Nginx)
Why added:
Serves static content (HTML, CSS, JS, images) quickly and forwards dynamic requests to the application server.

Role: Acts as a reverse proxy, caching static assets, and routing dynamic requests.

3. Application Server
Why added:
Hosts the backend application logic (e.g., Python/Django, Node.js).

Role: Processes business logic, communicates with the database, returns dynamic content.

4. Database Server (MySQL Primary-Replica Cluster)
Why added:
Stores and manages application data reliably.

Primary-Replica cluster:

Primary node: Handles all write operations and propagates changes to replicas.

Replica node(s): Handle read operations, offloading queries from primary.

Application difference:

Writes → Primary

Reads → Replica(s)

This improves performance and fault tolerance.

5. Application files (code base)
Where: Deployed on web & app servers so both can serve user requests.

Enables smooth operations, easy updates, and version control.

Issues with this Infrastructure
1. Single Points of Failure (SPOF)
Only one load balancer: If it goes down, the whole site is inaccessible.

Only one database primary node: If it fails, writes cannot happen.

Only one web server and one app server: If either goes down, that function is lost.

2. Security Issues
No firewall: No protection from unauthorized network traffic or attacks.

No HTTPS (SSL/TLS): Data between clients and servers is unencrypted, vulnerable to interception and man-in-the-middle attacks.

3. No Monitoring
No system to detect failures, performance bottlenecks, or security breaches.

Without monitoring, problems can go unnoticed until they cause downtime.